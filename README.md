## Commit 1 Reflection
In the handle_connection function, we make a new BufReader instance, which wraps a reference to the stream. It adds buffering, meaning it reads a larger chunk of data into memory at once. http_request collects the lines of the request that the browser sends to our server in a vector. The lines method then splits the stream of data into a String whenever it sees a newline byte, and then each String is mapped to a Result. Because we're slacking on error handling for this one, we just put in unwrap so that if errors show up, we just stop the program. The browser signals the end of a HTTP request by sending two newline characters in a row, so if we get a line that is the empty string, that signifies one request from the stream. After all is done, we print out the result.

## Commit 2 Reflection 
![alt text](image.png)
After this round of modifications, we've added fs to import the standard library’s filesystem module. We also added a status_line variable to hold the message's success data. To handle errors, we use unwrap() to stop the program. The variable contents store the results of hello.html read as a string, and the variable length stores the length of contents. Then, we use format! to add the file’s contents as the body of the success response. The as_bytes method is called on the response to convert the string data to bytes. As mentioned in the book, the write_all method on stream takes a '&[u8]' and sends those bytes directly down the connection. Because of this, we are able to see our hello.html webpage when we access the endpoint.